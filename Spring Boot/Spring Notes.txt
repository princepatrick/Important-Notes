Key words:

All Annotations: List of all annotations


Errors:

***************************
APPLICATION FAILED TO START
***************************

Description:

Parameter 0 of constructor in com.luv2code.springcoredemo.rest.DemoController required a bean of type 'com.luv2code.util.Coach' that could not be found.


Action:

Consider defining a bean of type 'com.luv2code.util.Coach' in your configuration.


Chatgpt project advice:
	Beginner Level Projects
		Simple REST API
			Create a basic REST API to manage a collection of resources, such as a list of books or users.
			Implement CRUD operations (Create, Read, Update, Delete).
			Use an in-memory database like H2 for simplicity.
			
		To-Do List Application
			Build a simple to-do list application.
			Allow users to add, view, update, and delete tasks.
			Use Thymeleaf for server-side rendering of the front end.
			
		User Authentication System
			Implement a basic user registration and login system.
			Use Spring Security for authentication and authorization.
			Store user credentials in an H2 database.
			
	Intermediate Level Projects
		Blog Application
			Develop a blog platform where users can create, edit, delete, and view blog posts.
			Implement user authentication and authorization.
			Use a relational database like MySQL or PostgreSQL for data storage.
			
		E-commerce Application
			Create a basic e-commerce platform with product listings, a shopping cart, and checkout functionality.
			Implement user authentication and order management.
			Integrate with a payment gateway (e.g., Stripe or PayPal).
			
		Weather Application
			Build an application that fetches weather data from a public API (e.g., OpenWeatherMap).
			Allow users to search for the current weather in different cities.
			Cache weather data to reduce the number of API calls.
			
	Advanced Level Projects
		Microservices Architecture
			Create a set of microservices for a complex application (e.g., an online marketplace).
			Implement services for user management, product catalog, order processing, and payment.
			Use Spring Cloud for service discovery, configuration management, and communication.
			
		Social Media Platform
			Develop a social media platform with features like user profiles, posts, comments, likes, and follows.
			Implement real-time notifications using WebSockets.
			Use Elasticsearch for searching posts and profiles.
			
		Online Learning Platform
			Build an online learning platform with courses, quizzes, and progress tracking.
			Implement user roles (e.g., students, instructors, admins).
			Use a combination of relational and NoSQL databases for different data storage needs.
			Integrate video streaming for course content.

For Projects see specific notes section

Doubts:
What is the use of @Entity
	Indicates a class is an entity
	They map to the database
	They allow mapping of the Java objects to the database tables
	
What is the use of @GeneratedValue and strategy parameter
	Used along with @Id
	Used to generate the id based on various parameters:
		AUTO: The persistence provider (Hibernate) gives the strategy. Default strategy is None.
		IDENTITY: Auto-Increment the column to generate the primary key value
		SEQUENCE: Uses a database sequence - generate unique values
		TABLE: Table is used to generate unique values
		
What is the use of getters and setters
	Controlled Access of objects or variables
	Essential part of encapsulation - ensuring internal state is modified in controlled ways
	Uses:
		Encapsulation of the access of data
			Direct access: exposes the data structure of the object to the end service calls. Hence any change needs to change everything from the calling objects as well.
			Getter and setter: They only expose the public interface to the end service calls. Hence, any change only needs to update the variables used into the interface and not the structure
		Validation and control:
			No validation or logic can be added into the direct access of the objects
		Lazy Loading / Computed Properties:
			Lazy Loading is the concept of loading some variable or property only when they are needed.
			With direct access the objects are always loaded at any given time - which leads to massive memory consumption
			Whereas with the getters and setters could be resisted as not all the properties are loaded during the object load time
		Read only or Write only properties:
			With direct access either read only or write only could be performed 
			With getters and setters we can control to have public getters and private setters controlling the accessibility.
		Debugging / Logging:
			You can perform debugging and logging using getters and setters which you cannot perform with normal direct access
		Polymorphism:
			You can overrride the properties that have been defined using a getter and setter whereas in direct access you cannot override the properties
		Backward Compatibility:
			If you expose an object via direct access and then in the future decide to add some logic then you need to go over and update each of the calls and structure to support the new supported method and all the calls that are to be done to the method.
			If you have a getter and setter already you could directly update it for easier updates.
		
	
Why do we need this.id - is this needed in Java as well
	this keyword is used to access the instance variables 
	Helps in distinguishing the instance variables from the method variables 
	
Why does creating RestAPI need - Spring Web, Spring Data JPA, H2 Database
	Not strictly needed - can use other technologies to - develop, persist and manage data
	But their purpose are:
	Spring Web:
		Purpose: infrastructure to build web application such as RESTful Web Services
		Features: Simplifies creation of REST endpoints, request handling and response generation
		Alternatives: Apache Struts, Jersey or custom-built solution
	Spring Data JPA: 
		Purpose: Simplify database access and management - Java Persistence API
		Features: Provides repository abstraction, CRUD operatiosn, query methods
		Alternatives: Hibernate, MyBatis, JDBC
	H2 Database:
		Purpose: An in-memory database - development and testing purposes
		Features: in-memory database - fast and easy
		Alternative: MySQL, PostgreSQL, Cassandra, and MongoDB
		
		What is the difference between In-memory and normal databases?
			The primary difference between an in-memory and a normal database is that the in-memory database completely stores the data in the RAM whereas the traditional database store in the hard disk and retrieve and store when the access is needed.
			
			Speed:
				In-Memory: Much Faster since the data is stored in the RAM
				Traditional: Much slower since the access needs to go to the disk and retrieve the data back.
			
			Persistence:
				In-memory: By default the data is not persisted but some databases like Redis and Memcached could persist the data through snapshots, logs etc to periodically save them. During crashes the default In-memory dbs lose the data in the memory, whereas in Redis all the data stored in memory from the previous crash are lost. 
				Traditional: They store and persist the data by the nature of it. The data is retained from the disk and most databases prevent data loss from crashes.
			
			Scalability:
				In-memory: They are not scalable due to the low memory in the RAM unless we perform sharding to tiered storage.
				Traditional: They are scalable since the memory is outsourced to an hard disk.
			
			ACID compliance:
				In-memory: Most In-memory lack ACID compliance while some - Redis and Memcached are ACID compliant
				Traditional: They are by nature ACID compliant.

When to create Interface and Classes
	Why to create interface:
		Defining Contracts - one common set of methods for all the classes/interfaces that work on this underneath
		Decoupling implementation from the usage - So that whenever you change the implementation you need to worry about the original implementation
		Multiple Implementations - When multiple classes have same set of implementation - define an interface - promotes polymorhphishm and allows interchangeable components
		Enhancing Testability - Help in creating unit tests - create mock implementations for the methods
	
	When to create classes:
		Represent real-world entities: To deal with real-world items and represent their relationship
		Encapsulation: Storing the variables and methods in one block - Promotes data security and protected access
		Reusability and inheritance: The code in the parent class can be reused in the subclasses or the functionality could be overridden in them
		Concrete implementation: When the parent class needs to have concrete implementation instead of abstract implementation as in interfaces
		Design flexible, maintainbable, and scalable applications
	
Difference between JpaRepository and JpaRepository<Book, Long> when to use the 2nd one
	JpaRepository - Interface providing genereic CRUD operations
	JpaRepository<Book, Long> - Creating an interface with the type as Book and the type of key as 'Long'
	
When we use @Autowired in a field in class 1 that refers to Class 2. Should we have any additional annotation in the Class 2 for it.
	Whenever we have @Autowired at a field, constructor, or method - the parameter is searched in application context - and if it is found the instance is loaded into the usage in the expected class
	
Why return bookRepository.findById(id) throws error but return bookRepository.findById(id).orElse(null); does not in Book Service Class
	The bookRepository.findById(id) returns an Optional<T>
	The Optional<Book> maybe returns a null or non-null 
	But sometimes this could return a null - which could cause a null pointer exception
	This could be avoided - by explicitly returning the type Book - which would return an object Book or null	
	
What is the importance of autowiring - why cant we just 
	Need to study again
	
Why Restcontroller
	It is a specialized annotation that combines @Controller and @ResponseBody
	It is used to take in the Request url and then give a response by default using @ResponseBody
	@RestController indicate the class is a Restful API
	@RequestMapping("/books") Indicates the common URL for all the paths
	@GetMapping(), @PostMapping(), @DeleteMapping
	@PathVariable is used to extract data from the URI
	@RequestBody is used to convert the input object into domain object
	
Why RequestMapping("")
	They are used to define the path the service is stored in
	
What is @PathVariable
	They are used to extract some value based on the variable or path mentioned in the URI
	
What is @RequestBody
	They are used to bind the HTTP request body into domain object

Ways to autowire the objects?
	@Primary
	@Qualifier
	Cofiguration classes - using name of the class
	Custom Qualifier Class - creating using @Interface, @Retention(RetentionPolicy.RUNTIME)

If I was previously working on a spring project in Intellij IDE and have its server running. Now if I simply open another spring project in another folder will the previous server be also running
	If you are opening the project in a new window - the older project and server is maintained to be running
	If you are opening the project in the same window - the older project and server could be running if the newer project runs at a new port number - mentioned in the configuration
		The previous server stops to run only when we manually stop it

what if I have a server running in port 8001 in window 1 and now I open up a new project in a new window in port 8001 again. How will both the server co-exist since I have the same port number.
	If you do so you will get an Address already in use use error:
		org.springframework.boot.web.server.WebServerException: Unable to start embedded Tomcat server
		...
		Caused by: java.net.BindException: Address already in use: bind
	You can rectify this issue - by defining a newer port number in the second project in applicaiton.properties or application.yml

What is the use of separate packages like - controller, model, repository, and service
	They are used to implement separation of concerns
	They are used to separate the functionalities of each sets of classes:
	Controller: An interface between the web and the application - Annotations - @Restcontroller and @Controller
	Model: The classes are considered to be tables in the database - Annotations - @Entity
	Repository: The classes act as an interface between the applicaiton and database - Annotations - @JpaRepository and @CRUDRepository
	Service: The class act as service class that handles the functions of the calls made at the controller - Annotations - @Service
	
When dealing with a boolean variable "Completed" in the @Entity file should we explicitly setCompletedTrue() and setCompletedFalse or should we do one method called flipCompleted() by checking the current value of "Completed" variable
	The first method is more explicit, clear but the only con is more verbose - using 2 method for 1 action
	The second mehtod is lesser in number of lines but could cause errors and be less explicit
	The first method is more preferred - if lots of actions need to be done and complicated conditions needs to be checked
	The second method is preferred when the condition is simple

Error when trying to add thymeleaf to handle with templates
Error: https://stackoverflow.com/questions/31944355/error-resolving-template-index-template-might-not-exist-or-might-not-be-acces
	Solution: I am new to spring spent an hour trying to figure this out.

			go to --- > application.properties

			add these :

			spring.thymeleaf.prefix=classpath:/templates/
			spring.thymeleaf.suffix=.html

What is the use of pom.xml
	It is used to define the configuration of the project used by Maven, a build automation tool. They are used to define the following details:
		Project Information
		Dependencies
		Build Information (Plugins)
		Repositories
		Profiles

what is the use of .gitignore
	They are used to define the files that need to be ignored by git version control. The type of files or folders are:
		Build output directories (target/, bin/)
		Dependency directories (node_modules/)
		Configuration file - sensitive information (application.properties)
		system-specific files (.DS_store, Thumbs.db)
	

What is the use of HELP.md
	They are used to define the resources to handle the spring projects

What is the use of mvnw
	This a shell script to run the maven code using a maven wrapper.
	They are useful in running with a maven version that is consistent to the project instead of the common maven version.

What is the use of mvnw.cd
	This is a batch script to run the maven code using a maven wrapper.
	This is same as mvnw but to run in windows

What are files of .md why not use .txt
	These are markdown files
	They can be converted into html and be displayed in the platforms like Github
	
What is a wrapper
	A wrapper is software that is built on top of an existing software to provide additional functionalities
		The project can run on the local version of the maven
		Developers can start working on project without manually installing the maven
		The project details could be added in the version control - making the build environment reproducible
	How maven-wrapper works
		When you run ./mvnw clean install it tries to run the maven 
		But if there is no maven installed already - search from maven-wrapper.properties
		Now based on this version run the ./mvnw clean install

What is String.class

When to use int and when Integer? what is the difference?

What is the use of RestTemplate? Do we have any other alternatives

What advantage int[] have over ArrayList

ArrayList<int> arr = new ArrayList<int>(); what does <int> does and what does () does

Java Syntax:

ArrayList:

	ArrayList<Integer> arr = new ArrayList<Integer>();
	ArrayList<String> strArr = new ArrayList<String>();

	Methods:
	arr.add(5) //Adding a value
	arr.add(6) // [5,6]
	arr.add(8) // [5,6,8]
	arr.add(2,7) // [5,6,7,8]
	arr.set(2,9) // Setting (Replacing) value at a particular index
	arr.size() //4 (Finding size of the ArrayList

	Looping through:
	Method 1:
		for( int i=0 ; i<arr.size() ; i++ ){
			sout( arr[i] );
		}

	Method 2:
		for( int val : arr ) {
			sout( val );
		}

	Sort:
		Method 1:
			import java.util.Collections;
			
			Collections.sort( arr );
		
		Method 2:
			arr.sort( null ) // Default sorting method - if strings alphabetical, if numbers in ascending order
			arr.sort( Comparator comparator ) // Using the comparator 

	lastIndexOf() -> int

	arr.add(6) // [ 5, 6, 9, 8, 6, 8 ]
	arr.add(8) // [ 5, 6, 9, 8, 6, 8 ]

	arr.lastIndexOf(6) //4

	indexOf() -> int
	arr.indexOf(6) // 1

	contains() -> boolean

	if( arr.contains(5) ) -> True

	clone() -> Object

	ArrayList<String> arr2 = (ArrayList) arr.clone();

	toArray() -> Object[]

	Object[] arrArray = arr.toArray();

	subList() -> List<int>

	List<int> arrList = arr.subList();

Array:
	
	int[] arr = new int[5];
	arr[0] = 1
	arr[2] = 3
	
	int[] arr2 = { 2, 5, 8, 2, 1 }
	
String:
	

Questions to answer:
What does basic Spring security add to the spring project?
	By default providing spring security does the following to the project:
		Generates an automatic login page
		You cannot execute post requests anymore
		The application is on lockdown and prompts you to enter a username and password

What is Spring Security?
	Spring Security is really just a bunch of servlet filters that help you add authentication and authorization to your web application
	It integrates well with Spring boot
	Integrates well with standards like Oauth, or SAML
	Auto-generates login logout pages
	Protects the webpages from CSRF
	
What is a servlet?
	It is simply a program that you run on the server side

What is difference between authentication and authorization?
	Authentication verifies if the person who enters or tries to login is the intended person or not
	Authorization verifies the role or control the person who logged in has - For eg: An user could simply view the webpages while an admin could control and change the webpages
	

What are servlet filters?
	https://www.marcobehler.com/guides/spring-security#authentication-explained
	
What is a filter?

General architecture of the end to end spring naive security filter process:
	Client -> Security Filter -> Dispatcher Servlet @Controlller and @RestController
	
	Class SecurityFilter extends HttpFilter{
	
		void doFilter( HttpServletRequest request, HttpServletResponse response, HttpFilter filter ){
		
			extractUsernameAndPassword( request )
			
			notAuthenticated( token )
			
			notAuthorized( token, request )
			
			chain.doFilter( request, response )
		}		
		
	}
	
	The structure could big in this naive architecture for security filter - hence an improvement to divide the monster filter into few smaller components
		LoginMethodFilter
		AuthenticationFilter
		AuthorizationFilter
		
	chain.doFilter( request, response )
	
What is Spring Boot BOM ( Bill of Materials)

What is gradle?
	What is build.gradle, gradlew.bat, and gradlew files used for
		build.gradle contains the configurations that are available for the spring boot applicaiton
		gradlew is used in mac and linux to start a springboot applicaiton
		gradlew.bat is used in windows to start a springboot applicaiton
	
	What does the command ./gradlew.bat clean build do
		clean	
			It is used to remove all the files that are present in the /build folder
		
		build 
			It is used to build the files back into the /build folder
			It recompiles the files, runs the unit tests, and 

Difference between WAR and JAR?
	.jar and .war extensions
	.jar is to package multiple files into library, plugin, or any kind of application
	.war is used only for web applications
	
Difference between library, plugin and framework?
	Library:
		Provides reusable code to perform a specific tasks
		You control when to use a particular library
		Standalone in nature and not dependent on any host systems
		eg: Numpy
		for solving specific problems
	
	Plugin:
		Provides additional functionality to the application 
		integrated into a host applicatoin
		The plugin is dependent on the host system or application to work properly
		Eg: Intellij IDEA plugins
		for adding the utilities of the host application
	
	Framework:
		Provides a way to build structure application 
		It controls the flow and you fit your code into it;s structure
		Stands on it's own as the base of the application
		Spring, Django, Angular
		For building complete appllications

Spring data redis vs spring data Reactive Redis 

Dependencies for rate limiter
	starter web: To allow a web based java applications facilitating api calls in a request response model
	data redis 
	Lombok
	Devtools
	Actuator

What does @Bean and @Autowired do?
	@Bean on a method would mean that hte method creates and returns a Spring Bean of a specific type. Then this bean could be used by any other spring containers using some other annotations like @Autowired, @Inject
		The bean is then stored in a global place called Spring Application Context which I believe is like a global storage point.
	@Autowired is used to inject the dependency into your local method or variable.
		This finds the relevant Spring object from the Spring Application Context and then stores into the variable or method's parameter 
	
	Please read this thread for the following - https://chatgpt.com/share/6781fe46-b448-800b-aae7-93b2e0f6a4a9
		What is the use of @Bean
		What is the use of @Component, @Autowired, @Inject
		What is the difference between @Bean, and @Component
	
What is @SpringBootApplication used for?
	It is a convenience annotation that is combination of three annotations:
		@Configuration: This is used to define a class as a @Configuration class and that this is a source of bean definitions
		@EnableAutoConfiguration: This enables spring to automatically find the suitable beans based on the dependencies and configuration of the application
		@ComponentScan: Component scan goes through the entire spring application and identifies the sub-packages that are spring-managed components like @Component, @Service, @Repository, @Controller
	
What is @EnableScheduling used for?
	It provides the ability for Spring boot to run scheduled tasks at fixed intervals using @Scheduled annotation or cron expressions. 

What is the use of 

public static void main(String[] args){
	SpringApplication.run(RateLimiter.class, args);
}
	Run() methods to convert the 
		Initializes the spring context
		Performs auto configuration
		Starts the application if the app is a web based app then we use its own set of annotations (like controller etc) that keeps the application running.
		
//@AutoWired
TokenBucketService tokenBucketService
	We inject the TokenBucketService bean into the "tokenBucketService" and use it here
	
	Why is it commented:
		The bean could be manually configured or integrated into a custom filter chain, bypassing spring's dependency injection
		Bypassing spring's dependency injection - what does this mean
			"Bypassing Spring's dependency injection" means that instead of letting Spring automatically manage the lifecycle and injection of a bean (using `@Autowired` or similar), you manually create or initialize the bean and manage its dependencies yourself, outside of Spring's control. 

		For example:
			TokenBucketService service = new TokenBucketService(); // Manual initialization
			filter.setTokenBucketService(service); // Inject manually
		
		Here, Spring doesn't manage or inject the `TokenBucketService` into the filter.
	
Are servlets and controllers the same
	No, servlets and controllers are not the same:

	- Servlets: Low-level Java classes that handle HTTP requests and responses directly in a servlet container. They require manual handling of request parsing and response generation.
	  
	- Controllers: High-level components in frameworks like Spring MVC that abstract servlet functionality. Controllers are easier to use and focus on handling business logic, while the framework manages HTTP details behind the scenes.
	
What is manual registration of the bean
	Manual registration of a bean is when you explicitly define a bean in a @Configuration class using the @Bean annotation, instead of relying on Spring's automatic component scanning.

	@Bean
	public MyService myService() {
		return new MyService();
	}


Annotations List:
	@Component
	@Configuration
	@AutoConfiguration
	@ComponentScan
	@Bean
	@Slf4j
	@Autowired
	@Inject

Thread safety list:
	ConcurrentHashMap
	BlockingQueue
	ConcurrentLinkedDeque
	
Read this thread for all the questions about the RateLimiter implementation:
	https://chatgpt.com/share/6781fe46-b448-800b-aae7-93b2e0f6a4a9

@SpringBootApplication
@EnableScheduling
public class RateLimiterApplication {

	public static void main( String args[] ){
		SpringApplication.run( RateLimiterApplication.class, args );
	}
	
	@Bean
	public TokenBucket tokenBucket() {
		return new TokenBucket(5);
	}
	
}
	In this context, when does the tokenBucket() get called from
		
		The tokenBucket() method is called when the RateLimiterApplication class is run.

			Here's why:

			1. The `@SpringBootApplication` annotation is used to mark a class as a Spring Boot application.
			2. The `@EnableScheduling` annotation enables Spring's scheduling functionality in the application.
			3. The `main(String[] args)` method is the entry point of the application.
			4. When the `SpringApplication.run(RateLimiterApplication.class, args)` method is called, it starts the Spring Boot application.
			5. The `@Bean` annotation tells Spring Boot that the `tokenBucket()` method creates a bean.
			6. A bean is an object that is managed by the Spring container.
			7. Spring Boot will call the bean creation methods (annotated with `@Bean`) when it starts the application.
			8. Therefore, the `tokenBucket()` method is called during the application startup process, typically when the main method is executed.

What is use of Bean in Spring Boot?
	In **Spring Boot**, a **bean** is an object that is managed by the Spring framework's **Inversion of Control (IoC)** container. Beans are a central concept in Spring and are used to represent the components or services in an application.

	### Why Use Beans in Spring Boot?

	1. **Dependency Injection (DI):**
	   - Beans are used to enable **dependency injection**, where the framework automatically provides the required objects (dependencies) to other objects without manual instantiation.
	   - This promotes loose coupling and enhances testability.

	   **Example:**
	   ```java
	   @Component
	   public class UserService {
		   // Bean dependency injection
		   private final UserRepository userRepository;

		   public UserService(UserRepository userRepository) {
			   this.userRepository = userRepository;
		   }
	   }
	   ```

	2. **Centralized Configuration:**
	   - Beans allow you to manage object creation and lifecycle centrally, avoiding manual object creation (`new` keyword).

	3. **Reusability:**
	   - Beans are singletons by default (one instance per container), which makes them efficient and reusable throughout the application.

	4. **Automatic Management:**
	   - Spring Boot automatically detects and manages beans using annotations like `@Component`, `@Service`, and `@Repository`.

	5. **Custom Initialization and Destruction:**
	   - Beans support lifecycle methods, allowing you to define custom initialization and destruction logic using `@PostConstruct` and `@PreDestroy`.

	---

	### How to Define a Bean in Spring Boot?

	1. **Using Stereotype Annotations:**
	   The most common way is to use annotations such as:
	   - `@Component`: Generic bean.
	   - `@Service`: Represents a service layer bean.
	   - `@Repository`: Represents a data-access layer bean.
	   - `@Controller`/`@RestController`: Represents a web layer bean.

	   **Example:**
	   ```java
	   @Component
	   public class MyBean {
		   public void doSomething() {
			   System.out.println("Bean is working!");
		   }
	   }
	   ```

	2. **Using `@Bean` in Configuration Class:**
	   You can manually define beans in a configuration class using the `@Bean` annotation.

	   **Example:**
	   ```java
	   @Configuration
	   public class AppConfig {
		   @Bean
		   public MyBean myBean() {
			   return new MyBean();
		   }
	   }
	   ```

	3. **Automatically Detected Beans (Component Scanning):**
	   If you annotate your classes with the appropriate stereotype annotations and place them in the correct package, Spring Boot will detect and manage them automatically.

	---

	### Accessing Beans
	Beans can be injected using:
	- **Field Injection**: (not recommended)
	   ```java
	   @Autowired
	   private MyBean myBean;
	   ```

	- **Constructor Injection**: (recommended)
	   ```java
	   private final MyBean myBean;

	   @Autowired
	   public MyComponent(MyBean myBean) {
		   this.myBean = myBean;
	   }
	   ```

	- **Setter Injection**: (less commonly used)
	   ```java
	   private MyBean myBean;

	   @Autowired
	   public void setMyBean(MyBean myBean) {
		   this.myBean = myBean;
	   }
	   ```

	---

	### Bean Scope
	By default, a bean in Spring Boot is a **singleton** (one instance per container). However, you can change its scope using the `@Scope` annotation.

	**Example of Prototype Scope:**
	```java
	@Component
	@Scope("prototype")
	public class MyPrototypeBean {
	   // New instance is created every time
	}
	```

	---

	### Summary
	Beans in Spring Boot are crucial for managing the application’s components and enabling dependency injection. They provide:
	- Centralized control over object creation.
	- Efficient reuse of resources.
	- Clear separation of concerns.

	Let me know if you'd like to explore this further or need specific examples!

How beans promote loose coupling and enhances testability.
	Beans promote **loose coupling** and enhance **testability** by abstracting object creation and dependency management through **dependency injection (DI)**. Instead of creating dependencies manually with the `new` keyword, Spring injects them into beans, making components independent of specific implementations.

	### How This Helps:
	1. **Loose Coupling**:
	   - Beans interact through interfaces rather than concrete classes.
	   - Swapping implementations or making changes does not affect the dependent components.

	   **Example**: Replace `EmailService` with `SMSService` without modifying the consumer class:
	   ```java
	   @Autowired
	   private NotificationService notificationService; // Interface
	   ```

	2. **Enhances Testability**:
	   - Dependencies can be mocked or stubbed easily for unit testing.
	   - No need to modify code for testing; inject mocks into the beans during tests.

	   **Example**:
	   ```java
	   @Mock
	   private UserRepository userRepository;
	   @InjectMocks
	   private UserService userService; // Injects mock dependencies
	   ```

	This approach keeps the code flexible, maintainable, and test-friendly.
	
ConcurrentHashMap:
	https://www.geeksforgeeks.org/concurrenthashmap-in-java/
	The declaration: 

	```java
	public class ConcurrentHashMap<K, V> extends AbstractMap<K, V> implements ConcurrentMap<K, V>, Serializable
	```

	### Explanation:
	1. **Generic Class `<K, V>`**:
	   - `K`: Represents the type of keys in the map.
	   - `V`: Represents the type of values in the map.
	   - This allows the `ConcurrentHashMap` to be type-safe and work with any key-value pair types.

	2. **Extends `AbstractMap<K, V>`**:
	   - `AbstractMap` is a base class that provides a skeletal implementation of the `Map` interface.
	   - `ConcurrentHashMap` inherits its basic functionality (e.g., key-value storage and map operations) but overrides methods to provide thread-safe operations.

	3. **Implements `ConcurrentMap<K, V>`**:
	   - `ConcurrentMap` is a subinterface of `Map` that defines additional methods for atomic operations in a concurrent environment, such as `putIfAbsent()`, `remove()`, and `replace()`.
	   - `ConcurrentHashMap` ensures thread-safe updates and retrievals in multi-threaded environments.

	4. **Implements `Serializable`**:
	   - This enables instances of `ConcurrentHashMap` to be serialized (converted to a byte stream) so they can be transmitted over a network or saved to disk.

	---

	### Key Features of `ConcurrentHashMap`:
	- Thread-safe: Multiple threads can access and modify it without requiring external synchronization.
	- High performance: Achieved through **segmentation** (in earlier versions) or a **concurrent locking mechanism** to reduce contention.
	- No nulls: `null` keys or values are **not allowed**.

	This makes `ConcurrentHashMap` ideal for use in multi-threaded applications requiring efficient and safe data structures.

how does implement and extend work? what can be implemented and what can be extend and what can implement and what can extend?

	In Java, **`implements`** and **`extends`** are keywords used to define relationships between classes and interfaces. Here's a breakdown:

	---

	### **`extends`**
	- Used for **inheritance**, where a class or interface derives from a parent class or interface.
	- **What can `extend`?**
	  1. A **class** can extend another **class** (single inheritance).
		 - Example:
		   ```java
		   public class Dog extends Animal {
			   // Dog inherits Animal's properties and methods
		   }
		   ```
	  2. An **interface** can extend another **interface** (multiple inheritance for interfaces is allowed).
		 - Example:
		   ```java
		   public interface Walkable extends Movable {
			   // Walkable inherits methods from Movable
		   }
		   ```

	- **Key Points**:
	  - A class can extend only one class (**single inheritance**).
	  - An interface can extend multiple interfaces.

	---

	### **`implements`**
	- Used to establish a **contract** between a class and an interface. A class must provide implementations for all the methods declared in the interface.
	- **What can `implement`?**
	  1. A **class** can implement one or more **interfaces**.
		 - Example:
		   ```java
		   public class Car implements Vehicle, Movable {
			   // Must implement all methods from Vehicle and Movable
		   }
		   ```
	  2. An **interface** can also implement nothing (just act as a contract provider).

	- **Key Points**:
	  - A class can implement multiple interfaces (like multiple inheritance).
	  - Interfaces cannot implement anything—they can only **extend** other interfaces.

	---

	### Combining `extends` and `implements`
	A class can both **extend** a class and **implement** interfaces.
	- Example:
	  ```java
	  public class ElectricCar extends Vehicle implements Movable, Chargeable {
		  // ElectricCar inherits Vehicle and implements Movable & Chargeable
	  }
	  ```

	---

	### Summary Table:
	| Keyword      | Relationship          | Who Can Use?                  | Who Can Be Used With?       |
	|--------------|-----------------------|-------------------------------|-----------------------------|
	| `extends`    | Inheritance           | Classes, Interfaces           | Classes (single) or Interfaces (multiple) |
	| `implements` | Interface Implementation | Classes                       | Interfaces                  |

	Let me know if you'd like a specific example!

Intellij shortcuts:
	# IntelliJ IDEA Essential Shortcuts

	## Navigation
	| Action | Windows/Linux | Mac |
	|--------|--------------|-----|
	| Search Everywhere | Double Shift | Double Shift |
	| Go to Class | Ctrl + N | Cmd + O |
	| Go to File | Ctrl + Shift + N | Cmd + Shift + O |
	| Go to Line | Ctrl + G | Cmd + L |
	| Recent Files | Ctrl + E | Cmd + E |
	| Navigate Back/Forward | Ctrl + Alt + Left/Right | Cmd + Alt + Left/Right |
	| Find Usage | Alt + F7 | Alt + F7 |

	## Editing
	| Action | Windows/Linux | Mac |
	|--------|--------------|-----|
	| Basic Code Completion | Ctrl + Space | Ctrl + Space |
	| Smart Code Completion | Ctrl + Shift + Space | Ctrl + Shift + Space |
	| Quick Fix | Alt + Enter | Alt + Enter |
	| Format Code | Ctrl + Alt + L | Cmd + Alt + L |
	| Optimize Imports | Ctrl + Alt + O | Ctrl + Alt + O |
	| Comment/Uncomment Line | Ctrl + / | Cmd + / |
	| Duplicate Line | Ctrl + D | Cmd + D |
	| Delete Line | Ctrl + Y | Cmd + Backspace |
	| Move Line Up/Down | Alt + Shift + Up/Down | Alt + Shift + Up/Down |

	## Refactoring
	| Action | Windows/Linux | Mac |
	|--------|--------------|-----|
	| Rename | Shift + F6 | Shift + F6 |
	| Extract Variable | Ctrl + Alt + V | Cmd + Alt + V |
	| Extract Method | Ctrl + Alt + M | Cmd + Alt + M |
	| Extract Parameter | Ctrl + Alt + P | Cmd + Alt + P |
	| Extract Field | Ctrl + Alt + F | Cmd + Alt + F |

	## Running & Debugging
	| Action | Windows/Linux | Mac |
	|--------|--------------|-----|
	| Run | Shift + F10 | Ctrl + R |
	| Debug | Shift + F9 | Ctrl + D |
	| Step Over | F8 | F8 |
	| Step Into | F7 | F7 |
	| Resume Program | F9 | Cmd + Alt + R |
	| Toggle Breakpoint | Ctrl + F8 | Cmd + F8 |

	## Version Control
	| Action | Windows/Linux | Mac |
	|--------|--------------|-----|
	| Commit Changes | Ctrl + K | Cmd + K |
	| Update Project | Ctrl + T | Cmd + T |
	| Show Version Control | Alt + 9 | Cmd + 9 |
	| Push Commits | Ctrl + Shift + K | Cmd + Shift + K |

	## Window Management
	| Action | Windows/Linux | Mac |
	|--------|--------------|-----|
	| Toggle Project Window | Alt + 1 | Cmd + 1 |
	| Toggle Terminal | Alt + F12 | Alt + F12 |
	| Hide All Windows | Ctrl + Shift + F12 | Cmd + Shift + F12 |
	| Close Tab | Ctrl + F4 | Cmd + W |

	## Code Generation
	| Action | Windows/Linux | Mac |
	|--------|--------------|-----|
	| Generate Code | Alt + Insert | Cmd + N |
	| Override Methods | Ctrl + O | Ctrl + O |
	| Implement Methods | Ctrl + I | Ctrl + I |
	| Surround With | Ctrl + Alt + T | Cmd + Alt + T |

	## Search & Replace
	| Action | Windows/Linux | Mac |
	|--------|--------------|-----|
	| Find | Ctrl + F | Cmd + F |
	| Replace | Ctrl + R | Cmd + R |
	| Find in Files | Ctrl + Shift + F | Cmd + Shift + F |
	| Replace in Files | Ctrl + Shift + R | Cmd + Shift + R |

	## Tips for Learning Shortcuts
	1. Start with the most commonly used shortcuts (Quick Fix, Search Everywhere, and Basic Code Completion)
	2. Learn shortcuts for actions you perform frequently
	3. Use the "Key Promoter X" plugin to remind you of shortcuts
	4. Practice regularly to build muscle memory

What are the default accessibility of the methods and variables in java?
	Java has four **access specifiers** that control the visibility of classes, methods, and variables. Here’s an overview and guidance on when to use each:

	---

	### 1. **Private**
	   - **Scope**: Accessible only within the **same class**.
	   - **Use**: 
		 - For variables or methods that are part of the internal implementation and should not be accessible outside the class.
		 - Example: Helper methods, sensitive data like passwords.
	   - **Example**:
		 ```java
		 private int age;
		 private void calculateAge() {
			 // Internal logic
		 }
		 ```

	---

	### 2. **Default (Package-Private)**
	   - **Scope**: Accessible only within the **same package**.
	   - **Use**:
		 - For classes, methods, or variables that are intended to be used only by classes in the same package.
		 - Useful for organizing related functionality in the same package but keeping it hidden from other packages.
	   - **Example**:
		 ```java
		 int value; // default access
		 void display() {
			 System.out.println("Package-private method");
		 }
		 ```

	---

	### 3. **Protected**
	   - **Scope**: Accessible within the **same package** and by **subclasses** (even in different packages via inheritance).
	   - **Use**:
		 - For methods or variables that should be exposed to subclasses but not to the rest of the world.
		 - Useful in designing extensible class hierarchies.
	   - **Example**:
		 ```java
		 protected void displayMessage() {
			 System.out.println("Protected method");
		 }
		 ```

	---

	### 4. **Public**
	   - **Scope**: Accessible from **anywhere** (across all classes and packages).
	   - **Use**:
		 - For methods, variables, or classes that need to be universally accessible.
		 - Suitable for APIs or utility classes that are used across multiple packages.
	   - **Example**:
		 ```java
		 public void greet() {
			 System.out.println("Public method");
		 }
		 ```

	---

	### **When to Use Which Access Specifier**
	- **Private**: When encapsulating sensitive or internal details that should not be exposed.
	- **Default**: When limiting access to classes within the same package without exposing them externally.
	- **Protected**: When designing extensible classes that allow subclass access but restrict general access.
	- **Public**: For methods, classes, or variables that are part of the public-facing API or need global visibility.

	Choosing the appropriate access specifier helps in maintaining **encapsulation** and ensures **controlled access**, improving code modularity and security.
	
	To find the current time:
		We use java.time.LocalTime. Lets see a sample usage below:
			import java.time.LocalTime;
			LocalTime currentTime = LocalTime.now();
			int hour = currentTime.getHour();
			int minute = currentTime.getMinute();
			
			String time = String.valueOf( hour ) + ":" +String.valueOf( minute );
			
			Use this in your usages:
		
		The other operations or classes that are available in java.time are:
			java.time.LocalDate
				Only dealing with dates
				We can add or remove the dates from the current date
			
			java.time.LocalTime
				Only dealing with time like above
				You can add remove the number of hours, minutes and seconds
				
			java.time.LocalDateTime
				When you are dealing with both Date and Time at the same time
				
How to find current jdk version in Intellij IDE?
	File -> Project Structure -> Project 
	Check Project SDK section to view current jdk version
	
What is the use of Spring-boot-starter-test: See the latter part of the thread - https://chatgpt.com/share/679f9d65-2f14-800b-b9a3-7d2921568958
	It is a bundle of common testing frameworks:
		Junit( Used for unit testing)
		Hamcrest ( Used for complex assertions that deals with string etc )
		Mockito ( Used for mocking dependencies in the class )
		Spring Test ( for integration testing with Spring )
		AssertJ ( for fluent assertion APIs )
		JSONAssert & JSONPath ( for json based assertions )
		
	Give a comparison between Junit vs Hamcrest vs Mockito:	
		Junit:
			Framework for writing unit tests, test runner and structure
			Use case: They are used to setup, break the code after usage, and the assertion based execution of the tests
			When to use: You have to setup the basic structure of the unit tests with basic level of assertions, setup and tear down the code before and unit tests
		
		Hamcrest:
			Helps in building expressive assertions 
			It improves the readability of the assertions 
			Use Case: Writing asssertion for complex object properties
			When to use: When you have to complex assertions and dealing with string based comparison, and a more readable assertiosn
		
		Mockito:
			They are used to mock the dependencies or the other dependent classes.
			They are used to simulate the fucttioning of the other classes by creating mock objects.
			Use case: If you want to simulate any dependent mock service or feature classes
			When to use: when you have dependent database API, service classes, and other classes in your project, whose functionality you want to mimic.
	
	Give a realistic use case where Junit, Hamcrest and Mockito are used together:
		Scenario:
			We have an Userservice class with a repository class called UserRepository which collects information from the database and brings back to the user.
			For the user service class, the user repository is an dependent class 
			We need to check that whether the retrieval method works or not when we use the userservice class to handle and retrieve the data using the userrepositoy class
		
		Class structure of the UserService, User, and UserRepository objects:
			import lombok.NoArgsConstructor
			import lombok.AllArgsConstructor
			import lombok.Getter
			import lombok.Setter
			import org.springframework.stereotype.Service
			import java.util.Optional
			
			@NoArgsConstructor
			@AllArgsConstructor
			@Getter
			@Setter
			public Class User{
				
				public Long id;
				public String name;
				public String email;
			
			}
			
			public interface UserRepository{
			
				Optional<User> findUserById(Long id);
				
			}
			
			@Service
			public Class UserService{
			
				UserRepository userRepository;
				
				public UserService( UserRepository userRepository ){
					this.userRepository = userRepository;
				}
				
				public User findUserByUserId( Long id ){
					
					return userRepository.findUserById(id).orElseThrow( () -> new RunTimeException("User not found") );
				
				}
			
			}
			
		Class structure and implementation of the test class:
			import static org.hamcrest.MatcherAssert.assertThat;
			import static org.hamcrest.Matchers.*;
			import static org.junit.jupiter.api.Assertions.assertThrows;
			import static org.mockito.Mockito.*;
			
			import org.junit.jupiter.api.BeforeEach;
			import org.junit.jupiter.api.AfterEach;
			import org.junit.jupiter.api.extension.ExtendWith;
			import org.mockito.Mock;
			import org.mockito.InjectMocks;
			import org.mockito.junit.jupiter.MockExtension;
			
			
			import java.util.Optional;
			
			@ExtendWith(MockExtension.class) //Brings the properties of the Mockito class into the Junit 5 test classes
			class UserServiceTest{
				
				//This helps in creating a mock object for the UserRepository class. Note that we do not have an implementation for this class instead we are
				//only creating the implementation when we are going to try in the individual @Test method 
				//THis gives leverage to the individual implementation to throw exception or to return an response object.
				@Mock
				UserRepository userRepository;
				
				//This helps in injecting the mock objects that is (UserRepository) object into the userService class
				@InjectMocks
				UserService userService;
				
				//This sets up the process to follow before the starting of the implementation of UserServiceTest
				@BeforeEach
				public void setup(){
				
				}
				
				//This is one implementation of the Unit Test.
				//In this implementation, we are looking at the positive test case where we achieve success where we find the user id 
				@Test
				public void testFindUserByUserId_Success(){
					
					User user = new User(1D, "John Doe", "johndoe@abc.com");
					when(userRepository.findUserById(1D)).thenReturn(Optional.of(user);
					
					User resultUser = userService.findUserByUserId(1D);
					
					assertThat( resultUser, is(notNullValue()));
					assertThat( resultUser.getName(), equalTo("John Doe") );
					assertThat( resultUser.getEmail(), equalTo("johndoe@abc.com") );					
				
				}
				
				//This is another implementation of the unit test
				//This implementation checks the negative scenario where there is an failure in finding the user by user id.
				@Test
				public void testFindUserByUserId_Failure(){
				
					when( userRepository.findUserById(99D)).thenReturn(Optional.empty());
					
					RuntimeException thrown = assertThrows(RunTimeException.class, () -> userService.getUserById(99D));
					
					assertThat( thrown.getMessage(), is("User not found") );
				
				}
			
			}
		
Setting up database Schema, Gradle, and Project from Scratch - Sreeja:
	https://chatgpt.com/share/67ac1153-5a50-800b-b792-fc8a26783fc7
	
Configure Gradle Steps:

Configure JDK Steps:

Configure Maven Steps:

			
		
	
All Annotations:
	@Bean
	@Component
	@ComponentScan
	@Service
	@Transactional
	@RestController
	@Autowired
	@RequestMapping( value="/", method= RequestMethod.GET )
	@EnableTransactionManagement
	@Value("${filter.type}")
	@PostConstruct
	@ConditionalOnProperty(name = "filter.type", havingValue = "leakybucketmeter")
	@Override
	@Scheduled( cron = "*/30 * * * * ?" )
	@Slf4j
	@RequestMapping("/")
	@RestController
	@GetMapping("limited")
	@Configuration
	@Bean
	@SpringBootApplication
	@ComponentScan({"com.example.ratelimiter"})
	@EnableScheduling
	@Getter (Lombok)
	@HttpServletRequest
	@HttpServletResponse
	@NoArgsConstructor
	@AllArgsConstructor
	@Getter
	@Setter
	@ExtendWith( MockExtension.Class )
	@Mock
	@InjectMocks
	@Test
	@BeforeEach
	@AfterEach

Gradle Groovy vs Gradle Kotlin:
	Let me break down the key differences between Gradle Groovy and Gradle Kotlin DSL build scripts.

	Key Differences:

	1. File Extensions and Names:
	- Groovy: Uses `.gradle` (build.gradle)
	- Kotlin: Uses `.gradle.kts` (build.gradle.kts)

	2. Syntax:
	```groovy
	// Groovy
	dependencies {
		implementation 'org.springframework.boot:spring-boot-starter-web:2.7.0'
	}
	```

	```kotlin
	// Kotlin
	dependencies {
		implementation("org.springframework.boot:spring-boot-starter-web:2.7.0")
	}
	```

	3. IDE Support:
	- Kotlin DSL: 
	  - Better IDE support with auto-completion
	  - Better refactoring capabilities
	  - Compile-time error checking
	  - Better navigation to sources
	- Groovy DSL:
	  - Limited IDE support
	  - Runtime error detection only
	  - Less robust auto-completion

	4. Performance:
	- Kotlin DSL: 
	  - Initially slower build times
	  - Better build caching
	  - Improved performance in recent versions
	- Groovy DSL:
	  - Generally faster initial build times
	  - Less build caching capabilities

	5. Learning Curve:
	- Groovy DSL:
	  - Easier for Java developers to learn
	  - More flexible syntax
	  - More forgiving with types
	- Kotlin DSL:
	  - Steeper learning curve
	  - Strict type safety
	  - Requires Kotlin knowledge

	6. Type Safety:
	- Kotlin DSL:
	  - Strong static typing
	  - Compile-time error detection
	  - Better refactoring support
	- Groovy DSL:
	  - Dynamic typing
	  - Runtime error detection
	  - More flexible but less safe

	7. Plugins Declaration:
	```groovy
	// Groovy
	plugins {
		id 'java'
		id 'org.springframework.boot' version '2.7.0'
	}
	```

	```kotlin
	// Kotlin
	plugins {
		id("java")
		id("org.springframework.boot") version "2.7.0"
	}
	```

	8. Project Configuration:
	```groovy
	// Groovy
	sourceCompatibility = '11'
	targetCompatibility = '11'
	```

	```kotlin
	// Kotlin
	java {
		sourceCompatibility = JavaVersion.VERSION_11
		targetCompatibility = JavaVersion.VERSION_11
	}
	```

	Recommendations:

	1. Use Kotlin DSL if:
	- You're starting a new project
	- Type safety is important
	- You want better IDE support
	- Your team is familiar with Kotlin
	- You're working on a long-term project

	2. Use Groovy DSL if:
	- You need faster initial build times
	- You have existing Groovy build scripts
	- Your team is more comfortable with Groovy/Java
	- You need simpler syntax
	- You're working on a smaller project

	The choice between Groovy and Kotlin DSL often depends on:
	- Team expertise
	- Project requirements
	- Build complexity
	- Development environment
	- Long-term maintainability needs

	Both are fully capable of handling Gradle builds, and the choice often comes down to team preference and specific project needs.
	
.zip vs .exe vs .msi:
	Use .zip if you want a portable setup (e.g., install on D:\Java\).
	Use .msi if you need easy installation with updates.
	Use .exe if you want the simplest installation
	
what is .md5 and .sha1
	

Questions on Feb 21st: Gradle Setup Issues: https://chatgpt.com/share/67b838b4-3de8-800b-af1f-4ef34814c202
	Question 1: org.gradle.api.internal.provider.AbstractProperty$PropertyQueryException: Failed to calculate the value of task ':compileJava' property 'javaCompiler'.

	Question 2: what does java --version mean what does it do

	Question 3: I have multiple java versions available how to update to a specific version. I want it to be updated in this project onlly not other projects

	Question 4: I have the following logs from gradle. Is it connected?
		Log:
		2:41:41 AM: Executing...

		Starting Gradle Daemon...
		Connected to the target VM, address: '127.0.0.1:59000', transport: 'socket'
		Gradle Daemon started in 2 s 662 ms

		> Task :help

		Welcome to Gradle 8.12.1.

		To run a build, run gradle <task> ...

		To see a list of available tasks, run gradle tasks

		To see more detail about a task, run gradle help --task <task>

		To see a list of command-line options, run gradle --help

		For more detail on using Gradle, see https://docs.gradle.org/8.12.1/userguide/command_line_interface.html

		For troubleshooting, visit https://help.gradle.org

		[Incubating] Problems report is available at: file:///D:/Prince/Git%20Projects/Dom%20Parser%20Spring%20Boot/domparser/domparser/build/reports/problems/problems-report.html

		Deprecated Gradle features were used in this build, making it incompatible with Gradle 9.0.

		You can use '--warning-mode all' to show the individual deprecation warnings and determine if they come from your own scripts or plugins.

		For more on this, please refer to https://docs.gradle.org/8.12.1/userguide/command_line_interface.html#sec:command_line_warnings in the Gradle documentation.

		BUILD SUCCESSFUL in 10s
		1 actionable task: 1 executed
		2:41:52 AM: Execution finished.
		Disconnected from the target VM, address: '127.0.0.1:59000', transport: 'socket'
	
	Question 5:
		Cannot resolve symbol 'SpringApplication'
		Cannot resolve symbol 'autoconfigure'

		Code:
		package com.example.domparser;

		import org.springframework.boot.SpringApplication;
		import org.springframework.boot.autoconfigure.SpringBootApplication;

		@SpringBootApplication
		public class DomParserApplication {

			public static void main(String[] args) {
				SpringApplication.run(DomParserApplication.class, args);
			}

		}
	
		Solution: Missed adding a dependency: implementation 'org.springframework.boot:spring-boot-starter'

	Question 6:	Is my server started. My logs were attached:
		
		3:03:25 AM: Executing ':DomParserApplication.main()'...

		> Task :compileJava
		> Task :processResources
		> Task :classes
		Connected to the target VM, address: 'localhost:59462', transport: 'socket'

		> Task :DomParserApplication.main()

		  .   ____          _            __ _ _
		 /\\ / ___'_ __ _ _(_)_ __  __ _ \ \ \ \
		( ( )\___ | '_ | '_| | '_ \/ _` | \ \ \ \
		 \\/  ___)| |_)| | | | | || (_| |  ) ) ) )
		  '  |____| .__|_| |_|_| |_\__, | / / / /
		 =========|_|==============|___/=/_/_/_/

		 :: Spring Boot ::                (v3.4.2)

		2025-02-21T03:03:33.489-05:00  INFO 14456 --- [dom-parser] [  restartedMain] c.e.domparser.DomParserApplication       : Starting DomParserApplication using Java 17.0.12 with PID 14456 (D:\Prince\Git Projects\Dom Parser Spring Boot\domparser\domparser\build\classes\java\main started by princ in D:\Prince\Git Projects\Dom Parser Spring Boot\domparser\domparser)
		2025-02-21T03:03:33.509-05:00  INFO 14456 --- [dom-parser] [  restartedMain] c.e.domparser.DomParserApplication       : No active profile set, falling back to 1 default profile: "default"
		2025-02-21T03:03:33.602-05:00  INFO 14456 --- [dom-parser] [  restartedMain] .e.DevToolsPropertyDefaultsPostProcessor : Devtools property defaults active! Set 'spring.devtools.add-properties' to 'false' to disable
		2025-02-21T03:03:33.602-05:00  INFO 14456 --- [dom-parser] [  restartedMain] .e.DevToolsPropertyDefaultsPostProcessor : For additional web related logging consider setting the 'logging.level.web' property to 'DEBUG'
		2025-02-21T03:03:35.305-05:00  INFO 14456 --- [dom-parser] [  restartedMain] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat initialized with port 8080 (http)
		2025-02-21T03:03:35.322-05:00  INFO 14456 --- [dom-parser] [  restartedMain] o.apache.catalina.core.StandardService   : Starting service [Tomcat]
		2025-02-21T03:03:35.322-05:00  INFO 14456 --- [dom-parser] [  restartedMain] o.apache.catalina.core.StandardEngine    : Starting Servlet engine: [Apache Tomcat/10.1.34]
		2025-02-21T03:03:35.381-05:00  INFO 14456 --- [dom-parser] [  restartedMain] o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing Spring embedded WebApplicationContext
		2025-02-21T03:03:35.381-05:00  INFO 14456 --- [dom-parser] [  restartedMain] w.s.c.ServletWebServerApplicationContext : Root WebApplicationContext: initialization completed in 1779 ms
		2025-02-21T03:03:35.949-05:00  INFO 14456 --- [dom-parser] [  restartedMain] o.s.b.d.a.OptionalLiveReloadServer       : LiveReload server is running on port 35729
		2025-02-21T03:03:36.002-05:00  INFO 14456 --- [dom-parser] [  restartedMain] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat started on port 8080 (http) with context path '/'
		2025-02-21T03:03:36.020-05:00  INFO 14456 --- [dom-parser] [  restartedMain] c.e.domparser.DomParserApplication       : Started DomParserApplication in 3.181 seconds (process running for 3.745)

Give me general rules for gradle.build file?
	Isnt gradle.build already managing the dependencies in the dependencies section (libs.versions.toml) what is the use of Gradle Version Catalog and Spring Boot BOM - answer in medium size response
	Could you provide the structure of the buildSrc folder that contains and maintains multiple build.gradle files - answer in medium size response
	.gradle Caching and parallel - answer in medium size response
	Explain in short what is a CI/CD pipeline, like what does it do
	How to integrate the build.gradle with a CI/CD pipeline, what should I do for it
	
	https://chatgpt.com/share/67ba39b8-aad8-800b-9f35-98baf52ba6b3

What is the use of a controller class in spring boot? What are the general rules and best practices while defining a controller class? Answer in long, detail and use technical terms that would help in an interview
	What is the use of API versioning (URI, Header and Parameter Versioning). Give me step by step process on how to achieve it and what is the advantage of it? Explain in detail?
	Give an example integrating Swagger API documentation with versioning with spring boot also is swagger api tightly bound to spring boot or can be used with other backend systems like spring boot
	Yes teach how to integrate Spring Security for JWT authentication with versioned APIs?
	
	https://chatgpt.com/share/67ba6f8d-8c94-800b-bcbe-4ef17e0c5390

What is the use of Spring Boot Model package. Why do we need it and what is stored in them. What are any best practices in defining and developing the model package.
	https://chatgpt.com/share/67ba71ca-b114-800b-b0a6-1311c4feb16a

What is the use of Service Layer in Spring Boot:
	What is the use of Exception folder in the Spring boot application and how to integrate with our code flow.
	How to integrate with logging exceptions or integrating with monitoring tools (e.g., ELK, Prometheus) - 
		Chatgpt: To effectively log exceptions and monitor your application, you can integrate logging frameworks like SLF4J + Logback and use monitoring tools like ELK (Elasticsearch, Logstash, Kibana) or Prometheus + Grafana.

	https://chatgpt.com/share/67ba733f-a0b0-800b-8cd4-91ed78ed3fd3
		Contains a set up for ELK, Prometheus and Grafana 

Targets are:
	Go through the annotations in Spring boot and try to understand or talk about 30 of them - write them here
		Core Spring Annotations: 
			@Component, @Bean, @Configuration, @Primary, @DependsOn, @Lazy
		Controller and Web Layer (Spring MVC): 
			@Restcontroller, @Controller, @RequestMapping, {@GetMapping, @PostMapping, @PutMapping, @DeleteMapping}, @PathVariable, @RequestParam, @RequestBody, @ResponseBody, @CrossOrigin, @ExceptionHandler, @ResponseStatus, @ModelAttribute - need to read
		Repository and Data Access Layer:
			@Repository, @Transactional, @EnableJpaRepositories, @Entity, @Table, @Column, @Id, @GeneratedValue, { @OneToOne / @OneToMany / @ManyToMany / @ManyToOne }, @JoinColumn - Need to read, @Query - Need to read
		Redis and Caching - Need to study later
		Service Layer: 
			@Service, @Transactional, @Async - Need to study later, @Scheduled, @EnableScheduling
	
Spring: Using Service and Utility Classes:
	https://chatgpt.com/share/67bd3155-bbfc-800b-9dd0-6b5fc46ef6c2
	
Spring: Spring Security Overview and Jwt setup:
	https://chatgpt.com/share/67c006cd-989c-800b-a6fe-d1f207cbc65b
	
Issues faced during Dom Parser setup for spring security on 02/25?
	Cannot resolve symbol 'Bean' and Cannot resolve symbol 'SecurityFilterChain' - I invalidated the cache and restarted the application.
		Learnt:
			This could be a CSRF issue 
			CSRF issue was previously resolved through extending WebSecurityConfigurerAdapter class and trying to disable CSRF
			But I found that the class is WebSecurityConfigurerAdapter  is deprecated and no longer available - hence, I am finding an alternate solution through:
			https://stackoverflow.com/questions/54177651/cannot-resolve-symbol-websecurityconfigureradapter
	The Gradle start or server start was throwing an error: "Cause: zip END header not found": The root cause of the issue - was that the Gradle downloaded cache was having some jars that were corrupted
		Learnt:
			The cache of the downloads for the specific software is present in C:\Users\prince\
			The cache for gradle is present in C:\Users\prince\.gradle
			We needed to delete the jar folder gradle-8.12.1 from C:\Users\princ\.gradle\wrapper\dists\gradle-8.12.1-bin\eumc4uhoysa37zql93vfjkxy0 as this contained the previously corrupted jars or missing jars 
	I added a dependency (io.jsonwebtoken.*) and started the server using server restart but when I tried to import with io.* I did not get the jsonwebtoken option at all, I also did not see the file in the external libraries section. I tried running gradle clean build, gradlew clean build and gradlew.bat clean build but I did not get the changes in library nor in the import command, Finally clicking the gradle icon on the ide helped in laoding the dependency into my external libraries section. 
		Learnt:
			gradle clean build - it uses the gradle file mentioned in the system variables path and tries to generate and store the jars at the build folder 
			gradlew and gradlew.bat clean build - It uses the gradle version that is set in our projects folder to generate and store the jars and they store the jars at the build folder and they use the version of java that is used in our local folder 
			clean build - This would clear the files in our build folder and then redownload the jars/fodlers again 
			After updating the dependencies list in build.gradle and doing the server restart, we see text stating that the jars are downloaded but I could not see it - this is actually stored in C:/users/X/.gradle/cache/module-2/file/... 
			On clicking the gradle icon, the files are being reset and jars are generated in the external libraries section and I was also able to see the same in the import statement from now.
	I was facing a long standing issue while setting up Jwt based authentication. The issue was throwing error during sending my request which is basically the dummy user name and passwsord to retrieve the bearer token to make the future calls. The error is due to the request did not have the right format - which until that point was using plain text. Now we updated the type of the request to use a json and application json. then it worked 
		Learnt:
			The type of the request matters to process the code. Since our request body is suited to handle applicaiton/json type we were not able to process with general text
			The flow of the code moves from filter -> controller. Our servlet path is only accessed and run at the controller portion where we have defined the /dom-parser/authenticate path
			The filter chain is basically a stream of filters that receives a request and sends the response to the next filter. This 13 filters complete their process to reach to dispather servlet which is basically something that takes up the request and contains threads to handle mutliple requests at the same time.
			THis dispather servlet would send the request to the controller class then to process the request.
			The url at the controller class matters to the very last character - "/dom-parser/authenticate/" for example the path was pointing to "/dom-parser/authenticate" and it was missing the last "/"
			I was previously returning a List<ParserResponse> object to the postman but there was some issue while returing the values hence, I had created a ResponseEntity<T> to the end user. The T could be anything - such as AuthenticationResponse, String etc.	
			I also had issues in handling the json request as the object was not able to parse or handle it. This was handled using the jakarta library. We installed the library - implementation 'jakarta.xml.bind:jakarta.xml.bind-api:2.3.2' and then the library helped to handle the json request.
	Now I received the token from the "/authenticate" call. This is called the bearer token. The bearer token is then used by the subsequent calls as the methodology to make the authentication calls. Now I was making the calls using the bearer token but still I was facing errors like 401 Unauthorized errors. The root cause of the error was "Method threw 'io.jsonwebtoken.ExpiredJwtException' exception." due to "JWT expired at 2025-02-26T18:51:23Z. Current time: 2025-02-27T00:34:46Z, a difference of 20603673 milliseconds.  Allowed clock skew: 0 milliseconds."
		Learnt:
			The issue was due to the bearer token or jwt token was expired
			The bearer token has a expiration time of 60 mins which was configured in applicaiton.properties
			A very simple of getting a new token is to again make a call to "/authenticate" which will get us a new token which can be used for the future calls for the next 60 minutes or until the expiration time. 
			Now making calls to the respective request /get-value/ with this token as the bearer token helps in making the calls to the necessary service.
			
	Authentication Error: 
		Access blocked: Authorization Error

		You can't sign in to this app because it doesn't comply with Google's OAuth 2.0 policy for keeping apps secure.

		You can let the app developer know that this app doesn't comply with one or more Google validation rules.
		Learn more about this error
		If you are a developer of Sample App, see error details.
		Error 400: invalid_request

		Error 400: invalid_request
		Request details: redirect_uri="http://localhost:8080/login/oauth2/code/google" flowName=GeneralOAuthFlow
			Learnt:
				The error is due to the setup of the client id where I had provided the  	

	
Spring OAuth Setup:
	The Oauth setup of spring application requires creating a client id and secret key at Google API Console.
	The steps to setup the client id is listed in: https://developers.google.com/identity/gsi/web/guides/get-google-api-clientid
	Again another setup steps from Chatgpt: https://chatgpt.com/share/67c3b224-f2b0-800b-90a9-55b4bd182e60

Prompt 01:
Web Dev General:
	Give the 100 most common technical terminologies in web development in general?
		like cookies, session and give the order in a way if I start searching them one by one I get an overall understanding of the most common technical terms to handle the software development overall.
	
		Possible Questions for later:
			Document oriented vs key value DB 
			ACID 
			Indexing
			Encryption vs Hashing
			CSRF
			XSS
			CORS
			Utility-first CSS
			Reverse Proxy
			Nginx
			Minification 
			Pagination
			Web Accessibilty (A11y)
			
			Section 10:
				Progressive Web Apps (PWAs)
				Single Page Application (SPA)
				Server Side Rendering (SSR)
				Client Side Rendering (CSR)
				WebAssembly (Wasm)
				Headless CMS 
				Edge Computing
				AI, Blockchain, Metaverse and Web3


Spring Security Notes:
		https://chatgpt.com/share/67ce1435-7d40-800b-81ae-8eff82e43441
		
		What is spring security?
			Spring security - powerful framework to securing spring applications 
			Authentication, authorization and protection against CSRF attacks
			Session-Fixation
			Method level security 
			
		Give the most important components involved in spring security? Give in an architectural way such that I can learn spring security overall?
			Architectural components of spring security:
				Authentication Process 
					It checks if the user is whome they claim to be. 
						Important Components:
							SecurityContext 
							SecurityContextHolder
							AuthenticationManager
							ProviderManager
							AuthenticationProvider 
							Userdetailsservice
				
				Authorization Process:
					Determines the person or user needs to be provided a particular access or not. 
						Important Components:
							AccessDecisionManager 
							AccessDecisionVoter
							GrantedAuthority
							SecurityMetadataSource
							@PreAuthorize, @PostAuthorize
					
				Filters:
					Spring security is a filter-based protection.
					You need to go through a bunch of filters before you can reach the application layer 
					
					Main Security Filters:
						UsernameAndPasswordAuthenticationFilter
						BasicAuthenticationFilter
						BearerTokenAuthenticationFilter
						SecurityContextPersistenceFilter
						ExceptionTranslationFilter
						CsrfFilter
						LogoutFilter 
				
				Security Configuration:
					XML based Configuration (older method)
					Java based Configuration (Modern method) - @EnableWebSecurity()
					SecurityContextFilters (since spring security 5.7)
					
					Key Classes and annotation:
						@EnableWebSecurity()
						SecurityFilterChain
						HttpSecurity
						AuthenticationManagerBuilder
						PasswordEncoder: eg BcryptPasswordEncoder
				
				Oauth and Jwt:
					Oauth2LoginConfigurer
					JwtDecoder
					JwtAuthenticationFilter					
				
				Additional Security Features :
					CSRF protection - Prevents CSRF attack CsrfFilter
					CORS Configuration - Manages cross origin requests (CORS)
					SesseionManagement
					MethodSecurity
					
		Architectural Diagram:
			User -> Security Filters -> AuthenticationManager -> AuthenticationProvider -> UserDetailsService -> application 
			
		Conclusion: 
			To configure spring security do the following:
				Configure SecurityFilterChain 
				Configure Userdetailsservice
				Use jwt or Oauth2 depending on needs 
				Apply security annotations for finer control				
			
			
	
	JWT related: 
	JWT:
		What is the steps involved in a JWT process - done already 
		What is a bearer token
			A bearer token is used for authentication and authorization
			Its called bearer token - since it allows every bearer the authentication into the application or resource they are requesting
			It is usually added in the Headers of the Authorization section of the request 
			It is usually represented using a JWT - Json Web Token 
			
		Why is it suitable for Rest based calls 
			It is suited with REST based calls due to stateless and compact nature 
			Stateless Authentication:
				REST prefers to have all the authentication information in each request so that they are stateless in nature 
				Bearer token is suited since it contains both - Authentication information and time for which the session should be present 
			
			Compact and Fast:
				It is compact, url safe, reducing overhead when transmitted with the Http request headers 
			
			Scalability:
				Since the authentication is handled by tokens instead of servers, JWT is ideal for distributed and microservice-based architectures
				
			Secure and Signed:
				Digitally signed using algorithms - HMAC-SHA256  or RSA - ensuring data integrity
				They can be additionally encrypted for additional security.
			
			
		What advantages JWT has over others and what are the possible drawbacks 
			JWT 
				Stateless
				Highly Scalable
				Compact 
				Cross-domain support 
				Highly secure( if properly signed and stored)
			
			Session based Authentication
				Not Stateless 
				Not scalable
				Not compact 
				does not support Cross domain support
				It is secure except CSRF
				
			Oauth (Opaque Tokens)
				Stateless
				Highly scalable 
				Usually Larger 
				supports cross-domain 
				Secure but requires token validation
				
		What is drawbacks of JWT:
			No built-in revocation:
				If a JWT expires - we cannot readly invalidate a JWT 
				instead for session based authentication - we can readily terminate teh access from the server 
				
				Solution:
					The blacklisting of the JWT tokens - using database or a redis server.
					
			Larger token size:
				JWTs - contain header, payload and signatures - making them larger than the general session ids.
			
			Potential Security Risks:
				If stored in localstorage - an XSS (cross-site scripting) can steal it 
				If used in log parameters - it can be logged and exposed. 
			
		What is a token in Jwt 
			A jwt token - self-contained string with - authentication and authorization claims 
			It contains 3 parts
			Header.Payload.Signature 
			
			eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiIxMjM0NTY3ODkwIiwiZXhwIjoxNjk3MTU4NzAwfQ.dBjftJeZ4CVP-mB92K27uhbUJU1p1r_w1gRfs2B4m2M
			
			1. Header 
			contains - metadata like algorithm - H256, R256
			{
				"alg"	: "H256",
				"typ" : "JWT"
			}
			
			2. Payload claims Base64 encoded json 
			{
				"userId" : "1234567890",
				"exp" : 1697158700
			}
			
			3. Signature 
			Ensures token integrity, preventing tampering
			
			
		Conclusion:
			Secure and stateless 
			suited for REST 
			It offers scalability and efficiency but revocation and storage security must be managed properly
			Suited for microservices and distributed authentication
			
			
			Followup questions:
				Why is it good for CSRF when session based authentication is not good for CSRF 
				
			
	
	Oauth related:
	Oauth2.0:
		What is Oauth2.0? - done in "Spring OAuth Setup"
		What is Google Oauth2.0 setup process? done in "Spring OAuth Setup"
		
		For the below:https://chatgpt.com/share/67ce6c5a-0ae8-800b-b0e5-34cdd47354da
		
		What is Google Client-id and secret
			A google client-id is the public identifier for your device 
			A Google secret is the password for your device 
			They are generated using Google cloud console when registering using Oauth 2.0 credentials
			
		What is Google Authorized Javascript Origins and Authorized Redirect URIs
			Google Authorized Javascript Origins:
				Used when implementing Oauth with Javascript (Web browser based apps)
				Restricts authentication requests to specifed domains 
				THis helps in preventing Cross-site Request Forgery attacks (CSRF attacks)
			
			Authorized Redirect URIs:
				Specifies where Google needs to send the authenticated resource to
				They have authorization code or access token to be sent 
				Used in Oauth based server side apps 
				Redirect URIs - should match exactly registered ones in Google Cloud Console 
				
		What is a google Oauth Authorized Domains
			THe domains from which google allows the web application to proceed 
			If you are having a web application that needs to use Google authentication - then it should follow the provided authorized domain 
			To use Google sign-in the domain must be verified by Google console. 
			
		Give a brief intro on the rules for the Authorized javascript origins 
			
		What are scopes? What are the type of scopes?
	
SOAP and REST basics - overview, and comparison:
	https://chatgpt.com/share/67ce80a4-0fd4-800b-8619-3f0b28308def
	
	What is SOAP? Give a brief introduction? What are advantages and disadvantages of SOAP service calls?
		Introduction:
			SOAP - Simple Object Access Protocol
			Helps in transferring structured information through the network 
			It is based on XML, platform independent and strict standard. 
			Uses standard protocols like HTTP, SMTP, TCP
			Supports WS-Security - critical for security and reliability 
		
		Advantage of SOAP service calls:
			Platform and Language Independence:
			Security - uses WS-Security
			Reliable messaging - Uses WS-ReliableMessaging
			Protocol Independence - Can operate over HTTP, SMTP, TCP 
			Extensibility - SOAP allows additional features like WS-specifications
			Stateful support - Can maintain session and transaction states 
		
		Disadvantage of SOAP service calls:
			Overhead due to XML: Since XML tends to be bigger we are getting into overhead to xmls
			Slower Performance: XML parsing takes more time than JSON parsing 
			Complexity: More complex than REST requires WSDL for service definition
			Tight Coupling: clients are coupled with the WSDL making the changes in the request more harder to implement.
			Limited Browser Support: relatively lesser support with browsers when compared to REST.
		
	Conclusion:
		High security, transactional integrity, and reliability - SOAP is good 
		For lightweight and fast services - prefer REST 
		
	Explain the important components and terms involved like WSDL, WS-Security, WS-ReliableMessaging, WS-specifications etc.
	What is Rest? Give a brief introduction? What are advantages and disadvantages of REST service calls?
	Give a detailed comparison between REST and SOAP


Slf4j Related:
	What is Slf4j? What are the uses of using Slf4j?
		Slf4j is an logging framework that abstracts the particular implementation of the logging that is currently used.
		There are various logging approaches like logback, java.util.logging, and Log4j each has it's own way of logging the text in the console. If we need to implement a particular logging method we might need to implemnent the code based on the logging framework's code base. 
		Lets say we started with one logging implementation and we need to move to a different type then we might need to change the code again. 
		What Slf4j does it provides an abstraction that makes it suitable to change the logging implementation at runtime.
		
		General features:
			Logging Abstraction:
				As discussed above, there are various logging methods that are supported like logback, java.util.logging, Log4j. 
				If we need to have one implementation that abstracts and suppports the other implementations in a generic version.
			
			Default Logging in Spring Boot:
				The default logging in Spring Boot is Logback - which is compatible with Slf4j
				If we need to change the default configurations (like what it should contain) we can use - logback.xml or application.properties 
			
			Structured and Consistent Logging:
				Slf4j supports parametrized logging which optimizes spring concatenation and improves performance:
				Code:
					logger.info("User {} logged in from IP {}", username, ipAddress);
					
			Integration with External Libraries:
				Basically java has the support for various logging libraries like - logback, java.util.logging, Log4j 
				But there are various external libraries for logging like Apache Commons Logging etc. Slf4j has support for these libraries as well. 
				Hence it is suited.
			
			Supports MDC( Mapped Diagnostic Context):
				It helps in adding contextual information to logs which helps in logging in a distributed environment
			
			Better performance with Asynchronous Logging:
				It supports Asynchronous logging - which is better for high-throughput applications.
		
		General Steps to Add a Logger with Slf4j:
			1. Adding the necessary dependency to setup or add the Slf4j logger:
			2. In the particular class where you want to log:
				//Create a logger object from the LoggerFactory
				//Using the logger object we create logs like logger.info() or logger.debug()
			3. In the application.properties we setup the properties that sets up the logger level, logger path, logger file's name
			
		What is Mapped Diagnostic Context?
			Mapped Diagnostic Context is a feature provided by Slf4j. 
			It helps in logging the information of context ie the user, service, thread, or request that is doing the current operation.
			This helps in monitoring or understanding which was the user/service/thread/request that made the particular call in any common implementation.	

			When and why to use MDC:
				Log Traceability: We can understand what exactly happened in a code flow 
				Multi-user environment: When multiple users operate with the same code then we will get to know which user had performed the particular operation.
				Multi-threaded environment: When multiple threads perform a particular operation. We will get to know the thread that performed the operation. 
				Microservices environment: The microservices architecture that points out the service that had done the action.
			
			How MDC Works?
				MDC stores the contextual data in a thread local variable.
				The stored variable is logged when it is referenced in the logger.
				
				Question:
					So when we login doing some operation the content is stored in MDC context but if we logout and come back again the information stored in MDC context will be lost is this correct. The only way to handle this would be to store some relevant info in the DB and then get the value back during the runtime. Is this correct.
			
			Using MDC in a Spring Boot Application:
				Add Dependencies:
					Should be the same dependencies that we used for SLF4J
				
				Add the usage of Slf4j in the class:
					import org.sf4j.MDC
					
					@RestController
					@RequestMapping
					public class ControllerClass{
						private static final Logger logger = LoggerFactory.getLogger(LoggingController.class);
						
						@GetMapping("/log")
						public String logExample(@RequestParam message){
							MDC.put("userId", userId);
							MDC.put("requestId",UUID.randomUUID().toString());
							
							logger.info("Processing for User");
							MDC.clear();
							return "Check the logs";
						}
					}
					
				Configuring the logback to use MDC:
					<configuration>
						<appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender">
							<encoder>
								<pattern>[%d] [%X{requestId}] [%X{userId}] %-5level %logger{36} - %msg%n </pattern>
							</encoder>
						</appener>
						
						<root level="INFO">
							<appender-ref ref="STDOUT"/>
						</root>
					</configuration>
				
				Using MDC in Async and Multi-threaded Applications:
					@Service
					public Async AsyncService{
						private static final Logger logger = LoggerFactory.getLogger(AsyncService.class);
						
						@Async
						public void asyncMethod(){
							String requestId = MDC.get("requestId");
							logger.info("Executing async task with requestId: {}", requestId);
						}
					}
			
			When to use MDC?
				Microservices logging:
				Multi-user Applications:
				Background/Async Processing:
				Debugging and Auditing:
				
		How is Asynchronous Logging different from Synchrnonous Logging? What concerns should we take into consideration? Why does high-throughput applications needs Asynchronous processing and Asynchronous Logging?
			Logging - debugging, analyzing, understanding what was the flow and what happened in the application.
			Logging - synchronously or asynchronously can impact systems in many ways. 
			
			Synchrnonous Logging:
				At synchronous logging - each line is printed before the next line is logged before the next line in the code execution can begin. 
				Every statement is executed using the application's main execution thread. 
				App waits till the logging is complete before proceeding to the next executing line or code in the app.
				
				Advantages:
					No messages are lost 
					Messages are written in order 
					They are simple to implement 
					
				Disadvantages:
					There could be a huge overhead on the application - Logging is an intensive process involving - I/O calls, network calls, and file writing that slows down the application.
					Blocking Nature - It tends to block out the application - and the next line waits till the current line of the logging thread is processed.
					It is not suitable for realtime - high throughput applications 
			
			Asynchronous Logging:
				In logging the log statements are placed at a separate queue buffer.
				We have a separate thread called - logging thread that picks the message from the queue and executes the logging lines 
				The main thread is left intact, hence proceeds with the general functioning of the application.
				
				Advantages:
					It improves the performance since the since the main thread does not work with the messages anymore and could operate with the app code 
					It is suited for applications that demand high scalability.
					Efficiently uses the resources
					
				Disadvantages:
					Potential Message Loss: It leads to potential message loss as message is handled by separate threads and the failure of logging thread could stop the logging statement from running but the application thread could move forward leading to a future scope which has not been recorded yet.
					Printed in different order: Since the added logs are implemented in the buffer and written separately, the logs might be written in different orders.
					Extra Memory: The queue requires extra space and some improper sizing could lead to delays.
			
			Advantages and essential nature of Asynchronous processing and Asynchronous logging in Real time systems, Microservices etc.,
				Asynchronous Processing:
					Minimizes thread blocking 
					Handles concurrent requests 
					Essential for microservices 
					
				Asynchronous Logging:
					Reduces logging overhead
					Supports concurrent threads 
					Enhances performances 
			
			<configuration>
				<appender name="ASYNC">
					<appender-ref ref="FILE">
				</appender>
				
				<appender name="FILE">
					<file></file>
					<encoder>
						<pattern></pattern>
					</encoder>
				</appender>
				
				<root level="INFO">
					<appender-ref ref="ASYNC">
				</root>
			</configuration>
					
				
			
		What does it mean by a "facade"? Can you explain?
			A Facade is used to create a simplified and unified interface on top of complex systems like Classes, libraries, or APIs
			Acts as a wrapper on top of set of functionalities and providing a simple interface for end users.
			
			Key Characteristics of a Facade:
				Simple Interface: The user is faced with a simplified interface calls only for the actions that they want to do with the application and are not exposed to the implementations 
				Reduces complexity: It reduces the complexity as the end user is not exposed to the implementation to the user 
				Reduces dependencies: The client code is decoupled from the implementation hence any changes to the implementation does not impact the client instead they are only aware of the actions they could request 
				Improves Maintainability: It improves maintainability because the implementation can be improved without the client being aware of the changes that were done.
			
			Example of a Facade in Real life:
				When we go to a hotel to book a room, 
					We simply goes to the receptionist and ask for a room 
						The receptionist collects the details from you about the type of room you want
						The receptionist finds a suitable room 
						The receptionist confirms it with you and ask for advance and adds into the billing portal handled by the billing team 
						The receptionist calls the room service guy to go and clean that room 
						The receptionist calls the helper to handle your luggage and deliver them in your room 
						The receptionist hands over the keys of the room to you 
					
					The receptionist is the facade. 
						The receptionist does not collect your details and ask you to go to the billing team 
						The billing team does not collect your payment and redirect you to the room of the Room Service Men 
						The Room service men does not clean the room and then ask you to go to the helpers room who can help carry your luggage 
						The helper does not redirect you to the receptionist to get the keys 
				
				A facade simply asks the end user to make an operation or ask for an action and facade should handle the implementation of the action instead of directing and giving directions to the end user about the directions to take.
				
			Two examples of a facade:
				The Slf4j is a simple facade for you to log the content without knowing the particular implementation of the logger like - java.util.logging, Logback, Log4j 
				
				The other example is an Audio system that has various complex subsystems like Amplifier, CDPlayer and Speakers 
				
				public class Amplifier{
					public void on(){ sout("Turn on the system"); }
					public void setVolumne( int volume : defaultVolume ){ sout("Volume set to" + volume);}
				}
				
				public class CDPlayer{
					public void play(String cd){ sout("Play the cd: " + cd); }
				}
				
				public class Speakers{
					public void setMode( String mode : defaultAudioMode ){ sout("Playing the speakers with the mode: " + mode);}
				}

				public class HomeTheaterFacade{
					Amplifier amplifier;
					CDPlayer cdPlayer;
					Speakers speaker;
					
					construct HomeTheaterFacade( Amplifier amplifier, CDPlayer cdPlayer, Speakers speaker ){
						this.amplifier = amplifier;
						this.cdPlayer = cdPlayer;
						this.speaker = speaker;
					}
					
					public void playMovie(){
						sout("Ask movie name");
						String movieName = getName();
						amplifier.on();
						amplifier.setVolume();
						speaker.setMode();
						cdPlayer.play(movieName);						
					}
				}
			
			When to use a facade:
				Complex system or subsystems 
				Decouple a client from the underlying service implementation 
				Need a standardized APIs for the system 
					
		
	How to setup logs configuration using Slf4j in Spring boot? What are the ways in setting up the logs lets say with java.util.Logging and Logback?
		Default logging is at level DEBUG 
		Hence any logging level lesser than DEBUG will not be printed 
		
		Configuring logs at Spring Boot:
			Default Logback:
				
				We can by default at applicaiton.properties for the default configuration:
					application.properties:
						logging.level.root=INFO 
						logging.level.org.springframework=DEBUG
						logging.level.com.example=TRACE 
						
						logging.file.name=logs/app.log 
						logging.file.path=logs 
						
						logging.pattern.console=%d{yyyy-mm-dd} - %msg%n 
					
					The application.properties configures the logging level of the root project at INFO, the spring related logs at DEBUG level and the program related logs at TRACE 
					
			Custom Logback:
				Using logback.xml using custom logback configuration:
					logback.xml at src/main/resources/
					
					<configuration>
						<appender>
							<encoder>
								<pattern>
							</encoder>
						</appender>
						
						<appender>
							<file>application.log</file>
							<encoder>
								<pattern>
							</encoder>
						</appender>
						<root level="INFO">
							<appender-ref name="STDOUT">
							<appender-ref name="FILE">
						</root>
						
						<logger name="com.example" level="DEBUG">
					</configuration>
				
			Java.util.Logging(JUL):
				1. Exclude logback from the application:
					<dependency>
						<groupId>org.springframework.boot</groupId>
						<artifactId>spring-boot-starter-logging</artifactId>
						<scope>provided</scope>
					</dependency>
				
				2. Add Slf4j and jul-to-slf4j bridge:
					<dependency>
						<groupId>org.slf4j</groupId>
						<artifactId>jul-to-slf4j</artifactId>
					<dependency>
				
				3. Initialize JUL Bridge in main()
					import java.util.logging.LogManager;
					
					import org.slf4j.bridge.SLF4JBridgeHandler;
					
					public class Logging{
						public static void setup(){
							LogManager.getLogManager.reset();
							SLF4JBridgeHandler.install();
						}
					}
				
			Log4j2 with Slf4j 
				Exclude logback from dependency 
				
				Add log4j2 dependency:
					<dependency>
						<groupId>org.springframework.boot</groupId>
						<artifactId>spring-boot-starter-log4j2</artifactId>
					</dependency>
					
				Add a log4j2.xml similar to logback.xml 
					<Configuration status="WARN">
						<Appenders>
							<!-- Console Appender -->
							<Console name="Console" target="SYSTEM_OUT">
								<PatternLayout pattern="%d{yyyy-MM-dd HH:mm:ss} [%t] %-5p %c{1} - %m%n"/>
							</Console>

							<!-- File Appender -->
							<File name="File" fileName="logs/app.log">
								<PatternLayout pattern="%d{yyyy-MM-dd HH:mm:ss} [%t] %-5p %c{1} - %m%n"/>
							</File>
						</Appenders>

						<Loggers>
							<!-- Set Log Levels -->
							<Root level="INFO">
								<AppenderRef ref="Console"/>
								<AppenderRef ref="File"/>
							</Root>

							<Logger name="com.example" level="DEBUG"/>
						</Loggers>
					</Configuration>
			
			Conclusion:
				LogBack:
					Default at Spring 
					Could be customized using logback.xml 
				
				Java.util.logging:
					Not default requires Jul-to-Slf4j Bridge 
					java.util.logging with Slf4j 
				
				Log4j2:
					Hanlded in log4j2.xml file 
			
			
			
						
					


